name: Deploy TTS Medical API to VPS

on:
  push:
    branches: [main]
    paths:
      - 'api/**'
      - '.github/workflows/**'
      - 'nginx/**'  # Ajouté pour surveiller les changements de config NGINX
  pull_request:
    branches: [main]
    paths:
      - 'api/**'

env:
  IMAGE_NAME: tts-medical-api
  CONTAINER_NAME: tts-medical-backend
  PORT: 5100  # CORRIGÉ: Port correct selon votre app Node.js

jobs:
  # Job de test avant déploiement
  test:
    name: 🧪 Run Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: 📂 Checkout repository
        uses: actions/checkout@v4

      - name: 🔧 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: 'api/package-lock.json'

      - name: 📦 Install dependencies
        working-directory: ./api
        run: npm ci

      - name: 🏗️ Build TypeScript
        working-directory: ./api
        run: npm run build

      - name: 🧪 Run tests
        working-directory: ./api
        run: npm test

      - name: 🐳 Test Docker build
        working-directory: ./api
        run: |
          docker build --target production -t ${{ env.IMAGE_NAME }}:test .
          docker run --rm -d --name test-container -p 5100:5100 ${{ env.IMAGE_NAME }}:test
          sleep 5
          docker stop test-container || true

  # Job de déploiement
  deploy:
    name: 🚀 Deploy to VPS
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: 📂 Checkout repository
        uses: actions/checkout@v4

      - name: 🔐 Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_URMAPHA_PRIVATE_SSH }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: 🧪 Test SSH Connection
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "echo '✅ SSH connection successful'"

      - name: 📦 Deploy application
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          set -e
          
          echo "🚀 [1/8] Préparation du déploiement..."
          PROJECT_DIR=~/tts-medical-management
          
          # Créer le répertoire et cloner/mettre à jour le projet
          echo "📦 [2/8] Mise à jour du code source..."
          if [ ! -d "$PROJECT_DIR" ]; then
            git clone https://github.com/AInelo/tts-medical-management.git $PROJECT_DIR
          else
            cd $PROJECT_DIR && git pull origin main
          fi
          
          cd $PROJECT_DIR/api
          
          # Backup de l'ancien conteneur (au cas où)
          echo "💾 [3/8] Sauvegarde de l'ancien conteneur..."
          if docker ps -a | grep -q ${{ env.CONTAINER_NAME }}; then
            docker commit ${{ env.CONTAINER_NAME }} ${{ env.IMAGE_NAME }}:backup-$(date +%Y%m%d-%H%M%S) || true
          fi
          
          # Build de la nouvelle image avec cache
          echo "🐳 [4/8] Construction de l'image Docker..."
          docker build \
            --target production \
            --tag ${{ env.IMAGE_NAME }}:latest \
            --tag ${{ env.IMAGE_NAME }}:$(date +%Y%m%d-%H%M%S) \
            .
          
          # Test de l'image avant déploiement
          echo "🧪 [5/8] Test de la nouvelle image..."
          docker run --rm --name ${{ env.CONTAINER_NAME }}-test \
            -e NODE_ENV=production \
            -e PORT=${{ env.PORT }} \
            ${{ env.IMAGE_NAME }}:latest node -e "console.log('✅ Image test successful')" || {
            echo "❌ Test de l'image échoué"
            exit 1
          }
          
          # Arrêt propre de l'ancien conteneur
          echo "🛑 [6/8] Arrêt de l'ancien conteneur..."
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            docker stop ${{ env.CONTAINER_NAME }} || true
            sleep 2
          fi
          docker rm ${{ env.CONTAINER_NAME }} || true
          
          # Démarrage du nouveau conteneur
          echo "🚀 [7/8] Démarrage du nouveau conteneur..."
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            -p ${{ env.PORT }}:${{ env.PORT }} \
            --restart unless-stopped \
            --memory="512m" \
            --cpus="0.5" \
            -e NODE_ENV=production \
            -e PORT=${{ env.PORT }} \
            ${{ env.IMAGE_NAME }}:latest
          
          # Vérification que le conteneur fonctionne
          echo "✅ [8/8] Vérification du déploiement..."
          sleep 15
          
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo "✅ Conteneur démarré avec succès"
            docker logs --tail=20 ${{ env.CONTAINER_NAME }}
          else
            echo "❌ Échec du démarrage du conteneur"
            docker logs ${{ env.CONTAINER_NAME }} || true
            exit 1
          fi
          
          # Test de connectivité avec vos routes API
          echo "🔍 Test de connectivité sur l'API..."
          sleep 5
          if curl -f -s --max-time 10 http://localhost:${{ env.PORT }}/api/ > /dev/null 2>&1; then
            echo "✅ API accessible sur /api/"
          else
            echo "⚠️  Test de connectivité - vérification manuelle nécessaire"
            echo "Status du conteneur: $(docker ps --filter name=${{ env.CONTAINER_NAME }} --format 'table {{.Status}}')"
          fi
          
          echo "🎉 Déploiement terminé avec succès !"
          EOF

      - name: 🔧 Setup Certbot and SSL Certificate
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          echo "🔐 [1/4] Installation et configuration SSL..."
          
          # Vérifier et installer Certbot si nécessaire
          if ! command -v certbot &> /dev/null; then
            echo "📦 Installation de Certbot..."
            sudo apt update
            sudo apt install -y certbot python3-certbot-nginx
          else
            echo "✅ Certbot déjà installé"
          fi
          
          # Vérifier si le certificat existe déjà
          DOMAIN="collection.urmaphalab.com"
          CERT_PATH="/etc/letsencrypt/live/$DOMAIN/fullchain.pem"
          
          if [ ! -f "$CERT_PATH" ]; then
            echo "🔐 Génération du certificat SSL pour $DOMAIN..."
            
            # Créer une configuration NGINX temporaire HTTP uniquement
            sudo tee /etc/nginx/sites-available/temp-http.conf > /dev/null << 'TEMP_CONF'
              server {
                  listen 80;
                  server_name collection.urmaphalab.com;
                  
                  # Location pour les challenges Let's Encrypt
                  location /.well-known/acme-challenge/ {
                      root /var/www/html;
                  }
                  
                  # Redirection temporaire vers l'API en HTTP
                  location / {
                      proxy_pass http://localhost:5100;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }
              }
              TEMP_CONF
                          
            # Activer la config temporaire
            sudo ln -sf /etc/nginx/sites-available/temp-http.conf /etc/nginx/sites-enabled/temp-http.conf
            sudo rm -f /etc/nginx/sites-enabled/default
            sudo rm -f /etc/nginx/sites-enabled/tts-medical.conf
            
            # Tester et recharger NGINX
            if sudo nginx -t; then
              sudo systemctl reload nginx
            else
              echo "❌ Erreur dans la configuration NGINX temporaire"
              exit 1
            fi
            
            # Créer le répertoire pour les challenges
            sudo mkdir -p /var/www/html/.well-known/acme-challenge
            sudo chown -R www-data:www-data /var/www/html
            
            # Générer le certificat
            echo "🔐 Génération du certificat SSL..."
            sudo certbot certonly \
              --webroot \
              --webroot-path=/var/www/html \
              --email admin@urmaphalab.com \
              --agree-tos \
              --no-eff-email \
              --domains $DOMAIN \
              --non-interactive
            
            if [ $? -eq 0 ]; then
              echo "✅ Certificat SSL généré avec succès"
            else
              echo "❌ Échec de la génération du certificat SSL"
              echo "⚠️  Continuité avec HTTP uniquement"
            fi
          else
            echo "✅ Certificat SSL existe déjà pour $DOMAIN"
            
            # Vérifier la validité du certificat (expire dans moins de 30 jours)
            if sudo certbot certificates | grep -A 5 "$DOMAIN" | grep -q "VALID: [0-2][0-9] days"; then
              echo "🔄 Renouvellement du certificat..."
              sudo certbot renew --quiet
            fi
          fi
          EOF

      - name: 🔧 Configure NGINX with SSL
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          PROJECT_DIR=~/tts-medical-management
          DOMAIN="collection.urmaphalab.com"
          CERT_PATH="/etc/letsencrypt/live/$DOMAIN/fullchain.pem"
          
          echo "🔧 [2/4] Configuration NGINX avec SSL..."
          
          # Vérifier plusieurs emplacements possibles pour la config NGINX
          NGINX_CONFIG=""
          if [ -f "$PROJECT_DIR/nginx/tts-medical.conf" ]; then
            NGINX_CONFIG="$PROJECT_DIR/nginx/tts-medical.conf"
          elif [ -f "$PROJECT_DIR/api/nginx.conf" ]; then
            NGINX_CONFIG="$PROJECT_DIR/api/nginx.conf"
          elif [ -f "$PROJECT_DIR/tts-medical.conf" ]; then
            NGINX_CONFIG="$PROJECT_DIR/tts-medical.conf"
          fi
          
          if [ -n "$NGINX_CONFIG" ]; then
            echo "🔧 Configuration NGINX trouvée: $NGINX_CONFIG"
            
            # Créer le répertoire nginx s'il n'existe pas
            sudo mkdir -p /etc/nginx/sites-available
            sudo mkdir -p /etc/nginx/sites-enabled
            
            if [ -f "$CERT_PATH" ]; then
              echo "✅ Certificat SSL disponible - Configuration HTTPS complète"
              
              # Copier la configuration complète avec SSL
              sudo cp "$NGINX_CONFIG" /etc/nginx/sites-available/tts-medical.conf
              
              # Supprimer la config temporaire
              sudo rm -f /etc/nginx/sites-enabled/temp-http.conf
            else
              echo "⚠️  Certificat SSL non disponible - Configuration HTTP uniquement"
              
              # Créer une version HTTP de la configuration
              sed '/listen 443/,/ssl_dhparam/d' "$NGINX_CONFIG" | \
              sed '/ssl_certificate/d' | \
              sed '/include.*ssl/d' | \
              sed 's/listen 80;/listen 80;\n    # SSL sera configuré lors du prochain déploiement/' | \
              sed '/return 301 https/d' | \
              sudo tee /etc/nginx/sites-available/tts-medical.conf > /dev/null
            fi
            
            # Créer le lien symbolique
            sudo ln -sf /etc/nginx/sites-available/tts-medical.conf /etc/nginx/sites-enabled/tts-medical.conf
            
            # Supprimer la config par défaut si elle existe
            sudo rm -f /etc/nginx/sites-enabled/default
            
            # Test de la configuration NGINX
            echo "🧪 Test de la configuration NGINX..."
            if sudo nginx -t; then
              echo "✅ Configuration NGINX valide"
              sudo systemctl reload nginx
              echo "✅ NGINX rechargé avec succès"
              
              # Vérifier le status de NGINX
              if sudo systemctl is-active nginx > /dev/null; then
                echo "✅ NGINX est actif et fonctionne"
                
                # Test de connectivité
                if [ -f "$CERT_PATH" ]; then
                  echo "🌐 Test HTTPS..."
                  if curl -f -s --max-time 10 https://$DOMAIN/ > /dev/null 2>&1; then
                    echo "✅ HTTPS accessible"
                  else
                    echo "⚠️  HTTPS non accessible - vérification manuelle nécessaire"
                  fi
                fi
                
                echo "🌐 Test HTTP..."
                if curl -f -s --max-time 10 http://$DOMAIN/ > /dev/null 2>&1; then
                  echo "✅ HTTP accessible"
                else
                  echo "⚠️  HTTP non accessible - vérification manuelle nécessaire"
                fi
              else
                echo "❌ Problème avec NGINX"
                sudo systemctl status nginx
              fi
            else
              echo "❌ Erreur dans la configuration NGINX"
              sudo nginx -t 2>&1
              echo "⚠️  Continuité du déploiement sans rechargement NGINX"
            fi
          else
            echo "⚠️  Aucun fichier de configuration NGINX trouvé"
            echo "📂 Contenu du répertoire projet:"
            ls -la $PROJECT_DIR/
            if [ -d "$PROJECT_DIR/nginx" ]; then
              echo "📂 Contenu du répertoire nginx:"
              ls -la $PROJECT_DIR/nginx/
            fi
          fi
          EOF

      - name: 🔄 Setup SSL Auto-Renewal
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          echo "🔄 [3/4] Configuration du renouvellement automatique SSL..."
          
          # Vérifier si le cron job existe déjà
          if ! sudo crontab -l 2>/dev/null | grep -q "certbot renew"; then
            echo "📅 Ajout du cron job pour le renouvellement automatique..."
            
            # Ajouter le renouvellement automatique (tous les jours à 3h du matin)
            (sudo crontab -l 2>/dev/null; echo "0 3 * * * certbot renew --quiet --post-hook 'systemctl reload nginx'") | sudo crontab -
            
            echo "✅ Renouvellement automatique configuré"
          else
            echo "✅ Renouvellement automatique déjà configuré"
          fi
          
          # Test du renouvellement
          echo "🧪 Test de renouvellement (dry-run)..."
          if sudo certbot renew --dry-run --quiet; then
            echo "✅ Test de renouvellement réussi"
          else
            echo "⚠️  Problème potentiel avec le renouvellement - vérification manuelle recommandée"
          fi
          EOF

      - name: 🧹 Cleanup old images
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          echo "🧹 Nettoyage des anciennes images..."
          # Garder seulement les 3 dernières images
          docker images ${{ env.IMAGE_NAME }} --format "{{.Tag}}" | grep -E '^[0-9]{8}-[0-9]{6}$' | sort -r | tail -n +4 | xargs -r -I {} docker rmi ${{ env.IMAGE_NAME }}:{} || true
          
          # Nettoyage général mais conservateur
          docker system prune -f
          echo "✅ Nettoyage terminé"
          EOF

      - name: 📊 Deployment Summary
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          echo "📊 RÉSUMÉ DU DÉPLOIEMENT"
          echo "======================="
          echo "🐳 Conteneur: $(docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep ${{ env.CONTAINER_NAME }})"
          echo "💾 Utilisation mémoire: $(docker stats --no-stream --format '{{.MemUsage}}' ${{ env.CONTAINER_NAME }})"
          echo "📈 CPU: $(docker stats --no-stream --format '{{.CPUPerc}}' ${{ env.CONTAINER_NAME }})"
          echo "🏷️  Image: $(docker images ${{ env.IMAGE_NAME }}:latest --format '{{.Size}}')"
          echo "⏰ Temps de démarrage: $(docker inspect ${{ env.CONTAINER_NAME }} --format='{{.State.StartedAt}}')"
          echo ""
          echo "🌐 URLs à tester:"
          echo "   - HTTP: http://collection.urmaphalab.com/api/"
          echo "   - HTTPS: https://collection.urmaphalab.com/api/"
          echo ""
          echo "🔐 Certificat SSL:"
          if [ -f "/etc/letsencrypt/live/collection.urmaphalab.com/fullchain.pem" ]; then
            echo "   ✅ Certificat SSL configuré"
            echo "   📅 Expiration: $(sudo openssl x509 -enddate -noout -in /etc/letsencrypt/live/collection.urmaphalab.com/fullchain.pem | cut -d= -f2)"
          else
            echo "   ⚠️  Certificat SSL non configuré (HTTP uniquement)"
          fi
          EOF

      - name: 🔔 Notify deployment status
        if: always()
        run: |
          if [ $? -eq 0 ]; then
            echo "✅ Déploiement réussi sur ${{ secrets.VPS_HOST }}"
            echo "🚀 Application accessible sur le port ${{ env.PORT }}"
          else
            echo "❌ Échec du déploiement"
            exit 1
          fi








# name: Deploy TTS Medical API to VPS

# on:
#   push:
#     branches: [main]
#     paths:
#       - 'api/**'
#       - '.github/workflows/**'
#       - 'nginx/**'  # Ajouté pour surveiller les changements de config NGINX
#   pull_request:
#     branches: [main]
#     paths:
#       - 'api/**'

# env:
#   IMAGE_NAME: tts-medical-api
#   CONTAINER_NAME: tts-medical-backend
#   PORT: 5100  # CORRIGÉ: Port correct selon votre app Node.js

# jobs:
#   # Job de test avant déploiement
#   test:
#     name: 🧪 Run Tests
#     runs-on: ubuntu-latest
#     if: github.event_name == 'pull_request'
    
#     steps:
#       - name: 📂 Checkout repository
#         uses: actions/checkout@v4

#       - name: 🔧 Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: '18'
#           cache: 'npm'
#           cache-dependency-path: 'api/package-lock.json'

#       - name: 📦 Install dependencies
#         working-directory: ./api
#         run: npm ci

#       - name: 🏗️ Build TypeScript
#         working-directory: ./api
#         run: npm run build

#       - name: 🧪 Run tests
#         working-directory: ./api
#         run: npm test

#       - name: 🐳 Test Docker build
#         working-directory: ./api
#         run: |
#           docker build --target production -t ${{ env.IMAGE_NAME }}:test .
#           docker run --rm -d --name test-container -p 5100:5100 ${{ env.IMAGE_NAME }}:test
#           sleep 5
#           docker stop test-container || true

#   # Job de déploiement
#   deploy:
#     name: 🚀 Deploy to VPS
#     runs-on: ubuntu-latest
#     if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
#     steps:
#       - name: 📂 Checkout repository
#         uses: actions/checkout@v4

#       - name: 🔐 Setup SSH key
#         run: |
#           mkdir -p ~/.ssh
#           echo "${{ secrets.VPS_URMAPHA_PRIVATE_SSH }}" > ~/.ssh/id_rsa
#           chmod 600 ~/.ssh/id_rsa
#           ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

#       - name: 🧪 Test SSH Connection
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "echo '✅ SSH connection successful'"

#       - name: 📦 Deploy application
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
#           set -e
          
#           echo "🚀 [1/8] Préparation du déploiement..."
#           PROJECT_DIR=~/tts-medical-management
          
#           # Créer le répertoire et cloner/mettre à jour le projet
#           echo "📦 [2/8] Mise à jour du code source..."
#           if [ ! -d "$PROJECT_DIR" ]; then
#             git clone https://github.com/AInelo/tts-medical-management.git $PROJECT_DIR
#           else
#             cd $PROJECT_DIR && git pull origin main
#           fi
          
#           cd $PROJECT_DIR/api
          
#           # Backup de l'ancien conteneur (au cas où)
#           echo "💾 [3/8] Sauvegarde de l'ancien conteneur..."
#           if docker ps -a | grep -q ${{ env.CONTAINER_NAME }}; then
#             docker commit ${{ env.CONTAINER_NAME }} ${{ env.IMAGE_NAME }}:backup-$(date +%Y%m%d-%H%M%S) || true
#           fi
          
#           # Build de la nouvelle image avec cache
#           echo "🐳 [4/8] Construction de l'image Docker..."
#           docker build \
#             --target production \
#             --tag ${{ env.IMAGE_NAME }}:latest \
#             --tag ${{ env.IMAGE_NAME }}:$(date +%Y%m%d-%H%M%S) \
#             .
          
#           # Test de l'image avant déploiement
#           echo "🧪 [5/8] Test de la nouvelle image..."
#           docker run --rm --name ${{ env.CONTAINER_NAME }}-test \
#             -e NODE_ENV=production \
#             -e PORT=${{ env.PORT }} \
#             ${{ env.IMAGE_NAME }}:latest node -e "console.log('✅ Image test successful')" || {
#             echo "❌ Test de l'image échoué"
#             exit 1
#           }
          
#           # Arrêt propre de l'ancien conteneur
#           echo "🛑 [6/8] Arrêt de l'ancien conteneur..."
#           if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
#             docker stop ${{ env.CONTAINER_NAME }} || true
#             sleep 2
#           fi
#           docker rm ${{ env.CONTAINER_NAME }} || true
          
#           # Démarrage du nouveau conteneur
#           echo "🚀 [7/8] Démarrage du nouveau conteneur..."
#           docker run -d \
#             --name ${{ env.CONTAINER_NAME }} \
#             -p ${{ env.PORT }}:${{ env.PORT }} \
#             --restart unless-stopped \
#             --memory="512m" \
#             --cpus="0.5" \
#             -e NODE_ENV=production \
#             -e PORT=${{ env.PORT }} \
#             ${{ env.IMAGE_NAME }}:latest
          
#           # Vérification que le conteneur fonctionne
#           echo "✅ [8/8] Vérification du déploiement..."
#           sleep 15
          
#           if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
#             echo "✅ Conteneur démarré avec succès"
#             docker logs --tail=20 ${{ env.CONTAINER_NAME }}
#           else
#             echo "❌ Échec du démarrage du conteneur"
#             docker logs ${{ env.CONTAINER_NAME }} || true
#             exit 1
#           fi
          
#           # Test de connectivité avec vos routes API
#           echo "🔍 Test de connectivité sur l'API..."
#           sleep 5
#           if curl -f -s --max-time 10 http://localhost:${{ env.PORT }}/api/ > /dev/null 2>&1; then
#             echo "✅ API accessible sur /api/"
#           else
#             echo "⚠️  Test de connectivité - vérification manuelle nécessaire"
#             echo "Status du conteneur: $(docker ps --filter name=${{ env.CONTAINER_NAME }} --format 'table {{.Status}}')"
#           fi
          
#           echo "🎉 Déploiement terminé avec succès !"
#           EOF

#       - name: 🔧 Configure NGINX
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
#           PROJECT_DIR=~/tts-medical-management
          
#           # Vérifier plusieurs emplacements possibles pour la config NGINX
#           NGINX_CONFIG=""
#           if [ -f "$PROJECT_DIR/nginx/tts-medical.conf" ]; then
#             NGINX_CONFIG="$PROJECT_DIR/nginx/tts-medical.conf"
#           elif [ -f "$PROJECT_DIR/api/nginx.conf" ]; then
#             NGINX_CONFIG="$PROJECT_DIR/api/nginx.conf"
#           elif [ -f "$PROJECT_DIR/tts-medical.conf" ]; then
#             NGINX_CONFIG="$PROJECT_DIR/tts-medical.conf"
#           fi
          
#           if [ -n "$NGINX_CONFIG" ]; then
#             echo "🔧 Configuration NGINX trouvée: $NGINX_CONFIG"
            
#             # Créer le répertoire nginx s'il n'existe pas
#             sudo mkdir -p /etc/nginx/sites-available
#             sudo mkdir -p /etc/nginx/sites-enabled
            
#             # Copier la configuration
#             sudo cp "$NGINX_CONFIG" /etc/nginx/sites-available/tts-medical.conf
            
#             # Créer le lien symbolique
#             sudo ln -sf /etc/nginx/sites-available/tts-medical.conf /etc/nginx/sites-enabled/tts-medical.conf
            
#             # Supprimer la config par défaut si elle existe
#             sudo rm -f /etc/nginx/sites-enabled/default
            
#             # Test de la configuration NGINX
#             echo "🧪 Test de la configuration NGINX..."
#             if sudo nginx -t; then
#               echo "✅ Configuration NGINX valide"
#               sudo systemctl reload nginx
#               echo "✅ NGINX rechargé avec succès"
              
#               # Vérifier le status de NGINX
#               if sudo systemctl is-active nginx > /dev/null; then
#                 echo "✅ NGINX est actif et fonctionne"
#               else
#                 echo "❌ Problème avec NGINX"
#                 sudo systemctl status nginx
#               fi
#             else
#               echo "❌ Erreur dans la configuration NGINX"
#               sudo nginx -t 2>&1
#               echo "⚠️  Continuité du déploiement sans rechargement NGINX"
#             fi
#           else
#             echo "⚠️  Aucun fichier de configuration NGINX trouvé"
#             echo "📂 Contenu du répertoire projet:"
#             ls -la $PROJECT_DIR/
#             if [ -d "$PROJECT_DIR/nginx" ]; then
#               echo "📂 Contenu du répertoire nginx:"
#               ls -la $PROJECT_DIR/nginx/
#             fi
#           fi
#           EOF

#       - name: 🧹 Cleanup old images
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
#           echo "🧹 Nettoyage des anciennes images..."
#           # Garder seulement les 3 dernières images
#           docker images ${{ env.IMAGE_NAME }} --format "{{.Tag}}" | grep -E '^[0-9]{8}-[0-9]{6}$' | sort -r | tail -n +4 | xargs -r -I {} docker rmi ${{ env.IMAGE_NAME }}:{} || true
          
#           # Nettoyage général mais conservateur
#           docker system prune -f
#           echo "✅ Nettoyage terminé"
#           EOF

#       - name: 📊 Deployment Summary
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
#           echo "📊 RÉSUMÉ DU DÉPLOIEMENT"
#           echo "======================="
#           echo "🐳 Conteneur: $(docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep ${{ env.CONTAINER_NAME }})"
#           echo "💾 Utilisation mémoire: $(docker stats --no-stream --format '{{.MemUsage}}' ${{ env.CONTAINER_NAME }})"
#           echo "📈 CPU: $(docker stats --no-stream --format '{{.CPUPerc}}' ${{ env.CONTAINER_NAME }})"
#           echo "🏷️  Image: $(docker images ${{ env.IMAGE_NAME }}:latest --format '{{.Size}}')"
#           echo "⏰ Temps de démarrage: $(docker inspect ${{ env.CONTAINER_NAME }} --format='{{.State.StartedAt}}')"
#           echo ""
#           echo "🌐 URLs à tester:"
#           echo "   - API: http://collection.urmaphalab.com/api/"
#           echo "   - HTTPS: https://collection.urmaphalab.com/api/"
#           EOF

#       - name: 🔔 Notify deployment status
#         if: always()
#         run: |
#           if [ $? -eq 0 ]; then
#             echo "✅ Déploiement réussi sur ${{ secrets.VPS_HOST }}"
#             echo "🚀 Application accessible sur le port ${{ env.PORT }}"
#           else
#             echo "❌ Échec du déploiement"
#             exit 1
#           fi
