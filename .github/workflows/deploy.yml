name: Deploy TTS Medical API to VPS

on:
  push:
    branches: [main]
    paths:
      - 'api/**'
      - '.github/workflows/**'
      - 'nginx/**'  # AjoutÃ© pour surveiller les changements de config NGINX
  pull_request:
    branches: [main]
    paths:
      - 'api/**'

env:
  IMAGE_NAME: tts-medical-api
  CONTAINER_NAME: tts-medical-backend
  PORT: 5100  # CORRIGÃ‰: Port correct selon votre app Node.js

jobs:
  # Job de test avant dÃ©ploiement
  test:
    name: ğŸ§ª Run Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: ğŸ“‚ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: 'api/package-lock.json'

      - name: ğŸ“¦ Install dependencies
        working-directory: ./api
        run: npm ci

      - name: ğŸ—ï¸ Build TypeScript
        working-directory: ./api
        run: npm run build

      - name: ğŸ§ª Run tests
        working-directory: ./api
        run: npm test

      - name: ğŸ³ Test Docker build
        working-directory: ./api
        run: |
          docker build --target production -t ${{ env.IMAGE_NAME }}:test .
          docker run --rm -d --name test-container -p 5100:5100 ${{ env.IMAGE_NAME }}:test
          sleep 5
          docker stop test-container || true

  # Job de dÃ©ploiement
  deploy:
    name: ğŸš€ Deploy to VPS
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: ğŸ“‚ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ” Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_URMAPHA_PRIVATE_SSH }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸ§ª Test SSH Connection
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "echo 'âœ… SSH connection successful'"

      - name: ğŸ“¦ Deploy application
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          set -e
          
          echo "ğŸš€ [1/8] PrÃ©paration du dÃ©ploiement..."
          PROJECT_DIR=~/tts-medical-management
          
          # CrÃ©er le rÃ©pertoire et cloner/mettre Ã  jour le projet
          echo "ğŸ“¦ [2/8] Mise Ã  jour du code source..."
          if [ ! -d "$PROJECT_DIR" ]; then
            git clone https://github.com/AInelo/tts-medical-management.git $PROJECT_DIR
          else
            cd $PROJECT_DIR && git pull origin main
          fi
          
          cd $PROJECT_DIR/api
          
          # Backup de l'ancien conteneur (au cas oÃ¹)
          echo "ğŸ’¾ [3/8] Sauvegarde de l'ancien conteneur..."
          if docker ps -a | grep -q ${{ env.CONTAINER_NAME }}; then
            docker commit ${{ env.CONTAINER_NAME }} ${{ env.IMAGE_NAME }}:backup-$(date +%Y%m%d-%H%M%S) || true
          fi
          
          # Build de la nouvelle image avec cache
          echo "ğŸ³ [4/8] Construction de l'image Docker..."
          docker build \
            --target production \
            --tag ${{ env.IMAGE_NAME }}:latest \
            --tag ${{ env.IMAGE_NAME }}:$(date +%Y%m%d-%H%M%S) \
            .
          
          # Test de l'image avant dÃ©ploiement
          echo "ğŸ§ª [5/8] Test de la nouvelle image..."
          docker run --rm --name ${{ env.CONTAINER_NAME }}-test \
            -e NODE_ENV=production \
            -e PORT=${{ env.PORT }} \
            ${{ env.IMAGE_NAME }}:latest node -e "console.log('âœ… Image test successful')" || {
            echo "âŒ Test de l'image Ã©chouÃ©"
            exit 1
          }
          
          # ArrÃªt propre de l'ancien conteneur
          echo "ğŸ›‘ [6/8] ArrÃªt de l'ancien conteneur..."
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            docker stop ${{ env.CONTAINER_NAME }} || true
            sleep 2
          fi
          docker rm ${{ env.CONTAINER_NAME }} || true
          
          # DÃ©marrage du nouveau conteneur
          echo "ğŸš€ [7/8] DÃ©marrage du nouveau conteneur..."
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            -p ${{ env.PORT }}:${{ env.PORT }} \
            --restart unless-stopped \
            --memory="512m" \
            --cpus="0.5" \
            -e NODE_ENV=production \
            -e PORT=${{ env.PORT }} \
            ${{ env.IMAGE_NAME }}:latest
          
          # VÃ©rification que le conteneur fonctionne
          echo "âœ… [8/8] VÃ©rification du dÃ©ploiement..."
          sleep 15
          
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo "âœ… Conteneur dÃ©marrÃ© avec succÃ¨s"
            docker logs --tail=20 ${{ env.CONTAINER_NAME }}
          else
            echo "âŒ Ã‰chec du dÃ©marrage du conteneur"
            docker logs ${{ env.CONTAINER_NAME }} || true
            exit 1
          fi
          
          # Test de connectivitÃ© avec vos routes API
          echo "ğŸ” Test de connectivitÃ© sur l'API..."
          sleep 5
          if curl -f -s --max-time 10 http://localhost:${{ env.PORT }}/api/ > /dev/null 2>&1; then
            echo "âœ… API accessible sur /api/"
          else
            echo "âš ï¸  Test de connectivitÃ© - vÃ©rification manuelle nÃ©cessaire"
            echo "Status du conteneur: $(docker ps --filter name=${{ env.CONTAINER_NAME }} --format 'table {{.Status}}')"
          fi
          
          echo "ğŸ‰ DÃ©ploiement terminÃ© avec succÃ¨s !"
          EOF

      - name: ğŸ”§ Setup Certbot and SSL Certificate
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          echo "ğŸ” [1/4] Installation et configuration SSL..."
          
          # VÃ©rifier et installer Certbot si nÃ©cessaire
          if ! command -v certbot &> /dev/null; then
            echo "ğŸ“¦ Installation de Certbot..."
            sudo apt update
            sudo apt install -y certbot python3-certbot-nginx
          else
            echo "âœ… Certbot dÃ©jÃ  installÃ©"
          fi
          
          # VÃ©rifier si le certificat existe dÃ©jÃ 
          DOMAIN="collection.urmaphalab.com"
          CERT_PATH="/etc/letsencrypt/live/$DOMAIN/fullchain.pem"
          
          if [ ! -f "$CERT_PATH" ]; then
            echo "ğŸ” GÃ©nÃ©ration du certificat SSL pour $DOMAIN..."
            
            # CrÃ©er une configuration NGINX temporaire HTTP uniquement
            sudo tee /etc/nginx/sites-available/temp-http.conf > /dev/null << 'TEMP_CONF'
              server {
                  listen 80;
                  server_name collection.urmaphalab.com;
                  
                  # Location pour les challenges Let's Encrypt
                  location /.well-known/acme-challenge/ {
                      root /var/www/html;
                  }
                  
                  # Redirection temporaire vers l'API en HTTP
                  location / {
                      proxy_pass http://localhost:5100;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }
              }
              TEMP_CONF
                          
            # Activer la config temporaire
            sudo ln -sf /etc/nginx/sites-available/temp-http.conf /etc/nginx/sites-enabled/temp-http.conf
            sudo rm -f /etc/nginx/sites-enabled/default
            sudo rm -f /etc/nginx/sites-enabled/tts-medical.conf
            
            # Tester et recharger NGINX
            if sudo nginx -t; then
              sudo systemctl reload nginx
            else
              echo "âŒ Erreur dans la configuration NGINX temporaire"
              exit 1
            fi
            
            # CrÃ©er le rÃ©pertoire pour les challenges
            sudo mkdir -p /var/www/html/.well-known/acme-challenge
            sudo chown -R www-data:www-data /var/www/html
            
            # GÃ©nÃ©rer le certificat
            echo "ğŸ” GÃ©nÃ©ration du certificat SSL..."
            sudo certbot certonly \
              --webroot \
              --webroot-path=/var/www/html \
              --email admin@urmaphalab.com \
              --agree-tos \
              --no-eff-email \
              --domains $DOMAIN \
              --non-interactive
            
            if [ $? -eq 0 ]; then
              echo "âœ… Certificat SSL gÃ©nÃ©rÃ© avec succÃ¨s"
            else
              echo "âŒ Ã‰chec de la gÃ©nÃ©ration du certificat SSL"
              echo "âš ï¸  ContinuitÃ© avec HTTP uniquement"
            fi
          else
            echo "âœ… Certificat SSL existe dÃ©jÃ  pour $DOMAIN"
            
            # VÃ©rifier la validitÃ© du certificat (expire dans moins de 30 jours)
            if sudo certbot certificates | grep -A 5 "$DOMAIN" | grep -q "VALID: [0-2][0-9] days"; then
              echo "ğŸ”„ Renouvellement du certificat..."
              sudo certbot renew --quiet
            fi
          fi
          EOF

      - name: ğŸ”§ Configure NGINX with SSL
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          PROJECT_DIR=~/tts-medical-management
          DOMAIN="collection.urmaphalab.com"
          CERT_PATH="/etc/letsencrypt/live/$DOMAIN/fullchain.pem"
          
          echo "ğŸ”§ [2/4] Configuration NGINX avec SSL..."
          
          # VÃ©rifier plusieurs emplacements possibles pour la config NGINX
          NGINX_CONFIG=""
          if [ -f "$PROJECT_DIR/nginx/tts-medical.conf" ]; then
            NGINX_CONFIG="$PROJECT_DIR/nginx/tts-medical.conf"
          elif [ -f "$PROJECT_DIR/api/nginx.conf" ]; then
            NGINX_CONFIG="$PROJECT_DIR/api/nginx.conf"
          elif [ -f "$PROJECT_DIR/tts-medical.conf" ]; then
            NGINX_CONFIG="$PROJECT_DIR/tts-medical.conf"
          fi
          
          if [ -n "$NGINX_CONFIG" ]; then
            echo "ğŸ”§ Configuration NGINX trouvÃ©e: $NGINX_CONFIG"
            
            # CrÃ©er le rÃ©pertoire nginx s'il n'existe pas
            sudo mkdir -p /etc/nginx/sites-available
            sudo mkdir -p /etc/nginx/sites-enabled
            
            if [ -f "$CERT_PATH" ]; then
              echo "âœ… Certificat SSL disponible - Configuration HTTPS complÃ¨te"
              
              # Copier la configuration complÃ¨te avec SSL
              sudo cp "$NGINX_CONFIG" /etc/nginx/sites-available/tts-medical.conf
              
              # Supprimer la config temporaire
              sudo rm -f /etc/nginx/sites-enabled/temp-http.conf
            else
              echo "âš ï¸  Certificat SSL non disponible - Configuration HTTP uniquement"
              
              # CrÃ©er une version HTTP de la configuration
              sed '/listen 443/,/ssl_dhparam/d' "$NGINX_CONFIG" | \
              sed '/ssl_certificate/d' | \
              sed '/include.*ssl/d' | \
              sed 's/listen 80;/listen 80;\n    # SSL sera configurÃ© lors du prochain dÃ©ploiement/' | \
              sed '/return 301 https/d' | \
              sudo tee /etc/nginx/sites-available/tts-medical.conf > /dev/null
            fi
            
            # CrÃ©er le lien symbolique
            sudo ln -sf /etc/nginx/sites-available/tts-medical.conf /etc/nginx/sites-enabled/tts-medical.conf
            
            # Supprimer la config par dÃ©faut si elle existe
            sudo rm -f /etc/nginx/sites-enabled/default
            
            # Test de la configuration NGINX
            echo "ğŸ§ª Test de la configuration NGINX..."
            if sudo nginx -t; then
              echo "âœ… Configuration NGINX valide"
              sudo systemctl reload nginx
              echo "âœ… NGINX rechargÃ© avec succÃ¨s"
              
              # VÃ©rifier le status de NGINX
              if sudo systemctl is-active nginx > /dev/null; then
                echo "âœ… NGINX est actif et fonctionne"
                
                # Test de connectivitÃ©
                if [ -f "$CERT_PATH" ]; then
                  echo "ğŸŒ Test HTTPS..."
                  if curl -f -s --max-time 10 https://$DOMAIN/ > /dev/null 2>&1; then
                    echo "âœ… HTTPS accessible"
                  else
                    echo "âš ï¸  HTTPS non accessible - vÃ©rification manuelle nÃ©cessaire"
                  fi
                fi
                
                echo "ğŸŒ Test HTTP..."
                if curl -f -s --max-time 10 http://$DOMAIN/ > /dev/null 2>&1; then
                  echo "âœ… HTTP accessible"
                else
                  echo "âš ï¸  HTTP non accessible - vÃ©rification manuelle nÃ©cessaire"
                fi
              else
                echo "âŒ ProblÃ¨me avec NGINX"
                sudo systemctl status nginx
              fi
            else
              echo "âŒ Erreur dans la configuration NGINX"
              sudo nginx -t 2>&1
              echo "âš ï¸  ContinuitÃ© du dÃ©ploiement sans rechargement NGINX"
            fi
          else
            echo "âš ï¸  Aucun fichier de configuration NGINX trouvÃ©"
            echo "ğŸ“‚ Contenu du rÃ©pertoire projet:"
            ls -la $PROJECT_DIR/
            if [ -d "$PROJECT_DIR/nginx" ]; then
              echo "ğŸ“‚ Contenu du rÃ©pertoire nginx:"
              ls -la $PROJECT_DIR/nginx/
            fi
          fi
          EOF

      - name: ğŸ”„ Setup SSL Auto-Renewal
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          echo "ğŸ”„ [3/4] Configuration du renouvellement automatique SSL..."
          
          # VÃ©rifier si le cron job existe dÃ©jÃ 
          if ! sudo crontab -l 2>/dev/null | grep -q "certbot renew"; then
            echo "ğŸ“… Ajout du cron job pour le renouvellement automatique..."
            
            # Ajouter le renouvellement automatique (tous les jours Ã  3h du matin)
            (sudo crontab -l 2>/dev/null; echo "0 3 * * * certbot renew --quiet --post-hook 'systemctl reload nginx'") | sudo crontab -
            
            echo "âœ… Renouvellement automatique configurÃ©"
          else
            echo "âœ… Renouvellement automatique dÃ©jÃ  configurÃ©"
          fi
          
          # Test du renouvellement
          echo "ğŸ§ª Test de renouvellement (dry-run)..."
          if sudo certbot renew --dry-run --quiet; then
            echo "âœ… Test de renouvellement rÃ©ussi"
          else
            echo "âš ï¸  ProblÃ¨me potentiel avec le renouvellement - vÃ©rification manuelle recommandÃ©e"
          fi
          EOF

      - name: ğŸ§¹ Cleanup old images
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          echo "ğŸ§¹ Nettoyage des anciennes images..."
          # Garder seulement les 3 derniÃ¨res images
          docker images ${{ env.IMAGE_NAME }} --format "{{.Tag}}" | grep -E '^[0-9]{8}-[0-9]{6}$' | sort -r | tail -n +4 | xargs -r -I {} docker rmi ${{ env.IMAGE_NAME }}:{} || true
          
          # Nettoyage gÃ©nÃ©ral mais conservateur
          docker system prune -f
          echo "âœ… Nettoyage terminÃ©"
          EOF

      - name: ğŸ“Š Deployment Summary
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
          echo "ğŸ“Š RÃ‰SUMÃ‰ DU DÃ‰PLOIEMENT"
          echo "======================="
          echo "ğŸ³ Conteneur: $(docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep ${{ env.CONTAINER_NAME }})"
          echo "ğŸ’¾ Utilisation mÃ©moire: $(docker stats --no-stream --format '{{.MemUsage}}' ${{ env.CONTAINER_NAME }})"
          echo "ğŸ“ˆ CPU: $(docker stats --no-stream --format '{{.CPUPerc}}' ${{ env.CONTAINER_NAME }})"
          echo "ğŸ·ï¸  Image: $(docker images ${{ env.IMAGE_NAME }}:latest --format '{{.Size}}')"
          echo "â° Temps de dÃ©marrage: $(docker inspect ${{ env.CONTAINER_NAME }} --format='{{.State.StartedAt}}')"
          echo ""
          echo "ğŸŒ URLs Ã  tester:"
          echo "   - HTTP: http://collection.urmaphalab.com/api/"
          echo "   - HTTPS: https://collection.urmaphalab.com/api/"
          echo ""
          echo "ğŸ” Certificat SSL:"
          if [ -f "/etc/letsencrypt/live/collection.urmaphalab.com/fullchain.pem" ]; then
            echo "   âœ… Certificat SSL configurÃ©"
            echo "   ğŸ“… Expiration: $(sudo openssl x509 -enddate -noout -in /etc/letsencrypt/live/collection.urmaphalab.com/fullchain.pem | cut -d= -f2)"
          else
            echo "   âš ï¸  Certificat SSL non configurÃ© (HTTP uniquement)"
          fi
          EOF

      - name: ğŸ”” Notify deployment status
        if: always()
        run: |
          if [ $? -eq 0 ]; then
            echo "âœ… DÃ©ploiement rÃ©ussi sur ${{ secrets.VPS_HOST }}"
            echo "ğŸš€ Application accessible sur le port ${{ env.PORT }}"
          else
            echo "âŒ Ã‰chec du dÃ©ploiement"
            exit 1
          fi








# name: Deploy TTS Medical API to VPS

# on:
#   push:
#     branches: [main]
#     paths:
#       - 'api/**'
#       - '.github/workflows/**'
#       - 'nginx/**'  # AjoutÃ© pour surveiller les changements de config NGINX
#   pull_request:
#     branches: [main]
#     paths:
#       - 'api/**'

# env:
#   IMAGE_NAME: tts-medical-api
#   CONTAINER_NAME: tts-medical-backend
#   PORT: 5100  # CORRIGÃ‰: Port correct selon votre app Node.js

# jobs:
#   # Job de test avant dÃ©ploiement
#   test:
#     name: ğŸ§ª Run Tests
#     runs-on: ubuntu-latest
#     if: github.event_name == 'pull_request'
    
#     steps:
#       - name: ğŸ“‚ Checkout repository
#         uses: actions/checkout@v4

#       - name: ğŸ”§ Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: '18'
#           cache: 'npm'
#           cache-dependency-path: 'api/package-lock.json'

#       - name: ğŸ“¦ Install dependencies
#         working-directory: ./api
#         run: npm ci

#       - name: ğŸ—ï¸ Build TypeScript
#         working-directory: ./api
#         run: npm run build

#       - name: ğŸ§ª Run tests
#         working-directory: ./api
#         run: npm test

#       - name: ğŸ³ Test Docker build
#         working-directory: ./api
#         run: |
#           docker build --target production -t ${{ env.IMAGE_NAME }}:test .
#           docker run --rm -d --name test-container -p 5100:5100 ${{ env.IMAGE_NAME }}:test
#           sleep 5
#           docker stop test-container || true

#   # Job de dÃ©ploiement
#   deploy:
#     name: ğŸš€ Deploy to VPS
#     runs-on: ubuntu-latest
#     if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
#     steps:
#       - name: ğŸ“‚ Checkout repository
#         uses: actions/checkout@v4

#       - name: ğŸ” Setup SSH key
#         run: |
#           mkdir -p ~/.ssh
#           echo "${{ secrets.VPS_URMAPHA_PRIVATE_SSH }}" > ~/.ssh/id_rsa
#           chmod 600 ~/.ssh/id_rsa
#           ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

#       - name: ğŸ§ª Test SSH Connection
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "echo 'âœ… SSH connection successful'"

#       - name: ğŸ“¦ Deploy application
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
#           set -e
          
#           echo "ğŸš€ [1/8] PrÃ©paration du dÃ©ploiement..."
#           PROJECT_DIR=~/tts-medical-management
          
#           # CrÃ©er le rÃ©pertoire et cloner/mettre Ã  jour le projet
#           echo "ğŸ“¦ [2/8] Mise Ã  jour du code source..."
#           if [ ! -d "$PROJECT_DIR" ]; then
#             git clone https://github.com/AInelo/tts-medical-management.git $PROJECT_DIR
#           else
#             cd $PROJECT_DIR && git pull origin main
#           fi
          
#           cd $PROJECT_DIR/api
          
#           # Backup de l'ancien conteneur (au cas oÃ¹)
#           echo "ğŸ’¾ [3/8] Sauvegarde de l'ancien conteneur..."
#           if docker ps -a | grep -q ${{ env.CONTAINER_NAME }}; then
#             docker commit ${{ env.CONTAINER_NAME }} ${{ env.IMAGE_NAME }}:backup-$(date +%Y%m%d-%H%M%S) || true
#           fi
          
#           # Build de la nouvelle image avec cache
#           echo "ğŸ³ [4/8] Construction de l'image Docker..."
#           docker build \
#             --target production \
#             --tag ${{ env.IMAGE_NAME }}:latest \
#             --tag ${{ env.IMAGE_NAME }}:$(date +%Y%m%d-%H%M%S) \
#             .
          
#           # Test de l'image avant dÃ©ploiement
#           echo "ğŸ§ª [5/8] Test de la nouvelle image..."
#           docker run --rm --name ${{ env.CONTAINER_NAME }}-test \
#             -e NODE_ENV=production \
#             -e PORT=${{ env.PORT }} \
#             ${{ env.IMAGE_NAME }}:latest node -e "console.log('âœ… Image test successful')" || {
#             echo "âŒ Test de l'image Ã©chouÃ©"
#             exit 1
#           }
          
#           # ArrÃªt propre de l'ancien conteneur
#           echo "ğŸ›‘ [6/8] ArrÃªt de l'ancien conteneur..."
#           if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
#             docker stop ${{ env.CONTAINER_NAME }} || true
#             sleep 2
#           fi
#           docker rm ${{ env.CONTAINER_NAME }} || true
          
#           # DÃ©marrage du nouveau conteneur
#           echo "ğŸš€ [7/8] DÃ©marrage du nouveau conteneur..."
#           docker run -d \
#             --name ${{ env.CONTAINER_NAME }} \
#             -p ${{ env.PORT }}:${{ env.PORT }} \
#             --restart unless-stopped \
#             --memory="512m" \
#             --cpus="0.5" \
#             -e NODE_ENV=production \
#             -e PORT=${{ env.PORT }} \
#             ${{ env.IMAGE_NAME }}:latest
          
#           # VÃ©rification que le conteneur fonctionne
#           echo "âœ… [8/8] VÃ©rification du dÃ©ploiement..."
#           sleep 15
          
#           if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
#             echo "âœ… Conteneur dÃ©marrÃ© avec succÃ¨s"
#             docker logs --tail=20 ${{ env.CONTAINER_NAME }}
#           else
#             echo "âŒ Ã‰chec du dÃ©marrage du conteneur"
#             docker logs ${{ env.CONTAINER_NAME }} || true
#             exit 1
#           fi
          
#           # Test de connectivitÃ© avec vos routes API
#           echo "ğŸ” Test de connectivitÃ© sur l'API..."
#           sleep 5
#           if curl -f -s --max-time 10 http://localhost:${{ env.PORT }}/api/ > /dev/null 2>&1; then
#             echo "âœ… API accessible sur /api/"
#           else
#             echo "âš ï¸  Test de connectivitÃ© - vÃ©rification manuelle nÃ©cessaire"
#             echo "Status du conteneur: $(docker ps --filter name=${{ env.CONTAINER_NAME }} --format 'table {{.Status}}')"
#           fi
          
#           echo "ğŸ‰ DÃ©ploiement terminÃ© avec succÃ¨s !"
#           EOF

#       - name: ğŸ”§ Configure NGINX
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
#           PROJECT_DIR=~/tts-medical-management
          
#           # VÃ©rifier plusieurs emplacements possibles pour la config NGINX
#           NGINX_CONFIG=""
#           if [ -f "$PROJECT_DIR/nginx/tts-medical.conf" ]; then
#             NGINX_CONFIG="$PROJECT_DIR/nginx/tts-medical.conf"
#           elif [ -f "$PROJECT_DIR/api/nginx.conf" ]; then
#             NGINX_CONFIG="$PROJECT_DIR/api/nginx.conf"
#           elif [ -f "$PROJECT_DIR/tts-medical.conf" ]; then
#             NGINX_CONFIG="$PROJECT_DIR/tts-medical.conf"
#           fi
          
#           if [ -n "$NGINX_CONFIG" ]; then
#             echo "ğŸ”§ Configuration NGINX trouvÃ©e: $NGINX_CONFIG"
            
#             # CrÃ©er le rÃ©pertoire nginx s'il n'existe pas
#             sudo mkdir -p /etc/nginx/sites-available
#             sudo mkdir -p /etc/nginx/sites-enabled
            
#             # Copier la configuration
#             sudo cp "$NGINX_CONFIG" /etc/nginx/sites-available/tts-medical.conf
            
#             # CrÃ©er le lien symbolique
#             sudo ln -sf /etc/nginx/sites-available/tts-medical.conf /etc/nginx/sites-enabled/tts-medical.conf
            
#             # Supprimer la config par dÃ©faut si elle existe
#             sudo rm -f /etc/nginx/sites-enabled/default
            
#             # Test de la configuration NGINX
#             echo "ğŸ§ª Test de la configuration NGINX..."
#             if sudo nginx -t; then
#               echo "âœ… Configuration NGINX valide"
#               sudo systemctl reload nginx
#               echo "âœ… NGINX rechargÃ© avec succÃ¨s"
              
#               # VÃ©rifier le status de NGINX
#               if sudo systemctl is-active nginx > /dev/null; then
#                 echo "âœ… NGINX est actif et fonctionne"
#               else
#                 echo "âŒ ProblÃ¨me avec NGINX"
#                 sudo systemctl status nginx
#               fi
#             else
#               echo "âŒ Erreur dans la configuration NGINX"
#               sudo nginx -t 2>&1
#               echo "âš ï¸  ContinuitÃ© du dÃ©ploiement sans rechargement NGINX"
#             fi
#           else
#             echo "âš ï¸  Aucun fichier de configuration NGINX trouvÃ©"
#             echo "ğŸ“‚ Contenu du rÃ©pertoire projet:"
#             ls -la $PROJECT_DIR/
#             if [ -d "$PROJECT_DIR/nginx" ]; then
#               echo "ğŸ“‚ Contenu du rÃ©pertoire nginx:"
#               ls -la $PROJECT_DIR/nginx/
#             fi
#           fi
#           EOF

#       - name: ğŸ§¹ Cleanup old images
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
#           echo "ğŸ§¹ Nettoyage des anciennes images..."
#           # Garder seulement les 3 derniÃ¨res images
#           docker images ${{ env.IMAGE_NAME }} --format "{{.Tag}}" | grep -E '^[0-9]{8}-[0-9]{6}$' | sort -r | tail -n +4 | xargs -r -I {} docker rmi ${{ env.IMAGE_NAME }}:{} || true
          
#           # Nettoyage gÃ©nÃ©ral mais conservateur
#           docker system prune -f
#           echo "âœ… Nettoyage terminÃ©"
#           EOF

#       - name: ğŸ“Š Deployment Summary
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
#           echo "ğŸ“Š RÃ‰SUMÃ‰ DU DÃ‰PLOIEMENT"
#           echo "======================="
#           echo "ğŸ³ Conteneur: $(docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep ${{ env.CONTAINER_NAME }})"
#           echo "ğŸ’¾ Utilisation mÃ©moire: $(docker stats --no-stream --format '{{.MemUsage}}' ${{ env.CONTAINER_NAME }})"
#           echo "ğŸ“ˆ CPU: $(docker stats --no-stream --format '{{.CPUPerc}}' ${{ env.CONTAINER_NAME }})"
#           echo "ğŸ·ï¸  Image: $(docker images ${{ env.IMAGE_NAME }}:latest --format '{{.Size}}')"
#           echo "â° Temps de dÃ©marrage: $(docker inspect ${{ env.CONTAINER_NAME }} --format='{{.State.StartedAt}}')"
#           echo ""
#           echo "ğŸŒ URLs Ã  tester:"
#           echo "   - API: http://collection.urmaphalab.com/api/"
#           echo "   - HTTPS: https://collection.urmaphalab.com/api/"
#           EOF

#       - name: ğŸ”” Notify deployment status
#         if: always()
#         run: |
#           if [ $? -eq 0 ]; then
#             echo "âœ… DÃ©ploiement rÃ©ussi sur ${{ secrets.VPS_HOST }}"
#             echo "ğŸš€ Application accessible sur le port ${{ env.PORT }}"
#           else
#             echo "âŒ Ã‰chec du dÃ©ploiement"
#             exit 1
#           fi
